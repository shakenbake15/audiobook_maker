    def export_audiobook(self): 
        directory_path = QFileDialog.getExistingDirectory(self, "Select an Audiobook Directory")
        if not directory_path:
            return  # Exit the function if no directory was selected
        
        dir_name = os.path.basename(directory_path)
        idx = 0

        # Ensure 'exported_audiobooks' directory exists
        exported_dir = os.path.join(directory_path, "exported_audiobooks")
        if not os.path.exists(exported_dir):
            os.makedirs(exported_dir)

        # Find a suitable audio file name with an incrementing suffix
        while True:
            new_audiobook_name = f"{dir_name}_audiobook_{idx}.wav"
            new_audiobook_path = os.path.join(exported_dir, new_audiobook_name)
            if not os.path.exists(new_audiobook_path):
                break  # Exit the loop once a suitable name is found
            idx += 1

        output_filename = new_audiobook_path

        # Load the JSON file
        audio_map_path = os.path.join(directory_path, 'text_audio_map.json')
        if not os.path.exists(audio_map_path):
            QMessageBox.warning(self, "Error", "The selected directory is not a valid Audiobook Directory. Make sure the text_audio_map.json exists which comes from generating an audio book.")
            return
        
        with open(audio_map_path, 'r', encoding='utf-8') as file:
            text_audio_map = json.load(file)

        # Sort the keys (converted to int), then get the corresponding audio paths
        sorted_audio_paths = [text_audio_map[key]['audio_path'] for key in sorted(text_audio_map, key=lambda k: int(k))]
        
        #sort the keys, then get the variable to know if it starts a paragraph
        First_Sentence = [text_audio_map[key]['sentence']['StartParagraph'] for key in sorted(text_audio_map, key=lambda k: int(k))]
        FSsilence = AudioSegment.silent(duration=500)

        combined_audio = AudioSegment.empty()  # Create an empty audio segment

        pause_length = (self.export_pause_slider.value()/10) * 1000 # convert to milliseconds
        silence = AudioSegment.silent(duration=pause_length)  # Create a silent audio segment of pause_length
    
        # Set the progress bar maximum value
        self.progress.setMaximum(len(sorted_audio_paths))

        # Iterate over sorted_audio_paths and First_Sentence simultaneously
        for audio_path, is_start_paragraph in zip(sorted_audio_paths, First_Sentence):
            audio_segment = AudioSegment.from_wav(audio_path)
            
            if is_start_paragraph:  # Check if the flag for StartParagraph is true
                combined_audio += FSsilence + audio_segment + silence   
            else:
                combined_audio += audio_segment + silence  # Append the audio segment followed by silence
#        for audio_path in sorted_audio_paths:
#            audio_segment = AudioSegment.from_wav(audio_path)
#            combined_audio += audio_segment + silence  # Append the audio segment followed by silence
#           if First_Sentence ==True:
#               combined_audio = FSsilence + combined_audio

        # Update the progress bar
        self.progress.setValue(i + 1)
        QApplication.processEvents()

        # If you don't want silence after the last segment, you might need to trim it
        if pause_length > 0:
            combined_audio = combined_audio[:-pause_length]

        # Export the combined audio
        combined_audio.export(output_filename, format="wav")

        print(f"Combined audiobook saved as {output_filename}")